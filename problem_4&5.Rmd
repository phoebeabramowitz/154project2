---
title: "Diagnostics and Reproducibility"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

```

## 4 Diagnostics
Disclaimer: The questions in this section are open-ended. Be visual and quantitative! The gold standard arguments would be able to convince National Aeronautics and Space Administration (NASA) to use your classification method—in which case Bonus points will be awarded.


# (a) Do an in-depth analysis of a good classification model of your choice by showing some diagnostic plots or information related to convergence or parameter estimation.
We could show a partition plot of the QDA, visualizing the boundary with the partimat() function in the 'klaR' package.
If QDA yields two discriminant functions, we could make a scatterplot of the points and compare their classifications. 

Assuming we do soft-SVM and use slacking variables, we could plot the results of the classification model against different values for the slack variable.

Not too sure what to do about convergence, but maybe KNN would be good for that? 

Bias-variance plots?
```{r}
pca_transformed <- prcomp(~ rad_DF + rad_CF + rad_BF + rad_AF + rad_AN, data=timagestrain,
                     scale. = TRUE)

loadings <- pca_transformed$rotation
scores <- pca_transformed$x
eigenvalues <- pca_transformed$sdev^2

PC1 <- scores[,1]

timagestrain$PC1 <- PC1

timagestrain
```


```{r}
second_KNN <- list()
tfour_feats <- list()
tfive_feats <- list()
for (i in 1:10){
  #All Second Split Method(Transformed)
  second_KNN[[i]] <- knn(timagestrain[,2:4], timagestest[,2:4], 
                         timagestrain$cloud_label, i)
  tfour_feats[[i]] <- knn(timagestrain[,2:5], timagestest[,2:5],
                        timagestrain$cloud_label, i)
  tfive_feats[[i]] <- knn(timagestrain[,c(2:5,9)], timagestest[,c(2:5,9)],
                        timagestrain$cloud_label, i)
  
}

second_accuracy <- list()
fourf_accuracy <- list()
fivef_accuracy <- list()
for (i in 1:10){
  second_accuracy[[i]] <- zero_one_loss(second_KNN[[i]], timagestest$cloud_label)
  fourf_accuracy[[i]] <- zero_one_loss(tfour_feats[[i]], timagestest$cloud_label)
  fivef_accuracy[[i]] <- zero_one_loss(tfive_feats[[i]], timagestest$cloud_label)
}

knndf <- data.frame(K = c(1,2,3,4,5,6,7,8,9,10), 
                Three_Features = unlist(second_accuracy),
                Four_Features = unlist(fourf_accuracy),Five_Features = unlist(fivef_accuracy))
knndftall1 <- melt(knndf, id = "K")

# ggplot((filter(knndftall1,variable != "untransformed_accuracy")), aes(x=K, y=value,color=variable)) +
ggplot(knndftall1, aes(x=K, y=value,color=variable)) +
  geom_point() + 
  geom_line() + 
  theme_minimal() +
  ggtitle("KNN Accuracy by K Value")+
  ylab("Accuracy on Transformed Data")
  
 
```

#Be sure doing B & C with KNN + PCA

# (b) For your best classification model(s), do you notice any patterns in the misclassification errors? Again, use quantitative and visual methods of analysis. Do you notice problems in particular regions, or in specific ranges of feature values?
Make a prediction-accuracy heat map for this. There's an example for LDA classification in the link below, but I think we could figure out how to apply it to whichever model we use (https://www.displayr.com/linear-discriminant-analysis-in-r-an-introduction/)

re-run the model (knn) with x,y data, and then make a map for where the errors occur. one color of false positive, and another color for false negative and observe. 

```{r}
eimage1 <- mutate(image1, image=1)
eimage2 <- mutate(image2, image=2)
eimage3 <- mutate(image3, image=3)
eimages <- split1(list(eimage1,eimage2,eimage3),spec = c(train = .8, test = .2))
eimagestrain <- eimages$train
eimagestest <- eimages$test
eimagestrain$PC1 <- PC1

eknnclasses <- knn(eimagestrain[,4:6], eimagestest[,4:6],eimagestrain$cloud_label,k=8)
eknnclasses <- ifelse(as.double(eknnclasses)==1,-1,1)
imtesterrors <- mutate(eimagestest, error_type =(eimagestest$cloud_label - eknnclasses))
#partial heatmap image1
ggplot(filter(imtesterrors,image==1))+
  geom_tile(aes(x=x, y=y, fill=factor(error_type)))+
  labs(fill= "Error Type",
       title="Errors on Test Subset: Image1")+
  theme_minimal()+
  scale_fill_manual(values=c("red","lightgrey","blue"),
                   labels=c("False Negative", "Accurate", "False Positive"))

ggplot(filter(imtesterrors,image==2))+
  geom_tile(aes(x=x, y=y, fill=factor(error_type)))+
  labs(fill= "Error Type",
       title="Errors on Test Subset: Image2")+
  theme_minimal()+
  scale_fill_manual(values=c("red","lightgrey","blue"),
                   labels=c("False Negative", "Accurate", "False Positive"))

ggplot(filter(imtesterrors,image==3))+
  geom_tile(aes(x=x, y=y, fill=factor(error_type)))+
  labs(fill= "Error Type",
       title="Errors on Test Subset: Image3")+
  theme_minimal()+
  scale_fill_manual(values=c("red","lightgrey","blue"),
                   labels=c("False Negative", "Accurate", "False Positive"))

```


# (c) Based on parts 4(a) and 4(b), can you think of a better classifier? How well do you think your model will work on future data without expert labels?
```{r}
#clunky
boost_imagestrain <- imagestrain[,1:11]
boost_imagestest <- imagestest[,1:11]
tboost_imagestrain <- timagestrain[,1:9]
tboost_imagestest <- timagestest[,1:9]

boost_imagestrain$cloud_label <- replace(boost_imagestrain$cloud_label, 
                                       boost_imagestrain$cloud_label == -1, 
                                       0)

boost_imagestest$cloud_label <- replace(boost_imagestest$cloud_label, 
                                       boost_imagestest$cloud_label == -1, 
                                       0)

tboost_imagestrain$cloud_label <- replace(tboost_imagestrain$cloud_label, 
                                       tboost_imagestrain$cloud_label == -1, 
                                       0)

tboost_imagestest$cloud_label <- replace(tboost_imagestest$cloud_label, 
                                       tboost_imagestest$cloud_label == -1, 
                                       0)
```


```{r}

a1 <- CVmodel_accuracy("gbm", tboost_imagestrain, 5, zero_one_loss, ".", "cloud_label")
a2 <- CVmodel_accuracy("gbm", boost_imagestrain, 5, zero_one_loss, ".", "cloud_label")

data.frame("transformed"=round(a1,3),"untransformed"=round(a2,3), row.names=rn)

# getting higher CV accuracy on untransformed data when boosting, so ill run boosting on untransformed test data
```

```{r}

boost_test <- gbm(cloud_label ~.,
                  data = boost_imagestrain,
                  distribution = "adaboost")

boost.pred <- predict(boost_test, boost_imagestest, n.trees = 100)
boost_pred <- rep(0, length(boost.pred))
boost_pred[boost.pred >= 0.5] = 1

data.frame("boosting_test_accuracy"=zero_one_loss(boost_pred, boost_imagestest$cloud_label))

table(boost_pred, boost_imagestest$cloud_label)

summary(boost_test)

# boosting is getting 91% accuracy on test set
```

## Boosting ROC
```{r}
par(mfrow=c(1,1))
boost_roc <- prediction(boost.pred, boost_imagestest$cloud_label)
boost_perf <- performance(boost_roc, "tpr", "fpr")
plot(boost_perf, colorize=TRUE, lwd=2, main="Boosting ROC curve")
```


# (d) Do your results in parts 4(a) and 4(b) change as you modify the way of splitting the data?
Almost all models work better on transformed data, except for boosting, which is very curious... need to write more about this, and show plots?

KNN accuracy Comparison for both splits, first 10 Ks
```{r}
#Create Tall Dataframe for ggplot with both splits
first_KNN <- list()
first_accuracy <- list()
for (i in 1:10){
  first_KNN[[i]] <- knn(imagestrain[,4:6], imagestest[,4:6],imagestrain$cloud_label, i)
  first_accuracy[[i]] <- zero_one_loss(first_KNN[[i]], imagestest$cloud_label)
}

knndfsplits <- data.frame(K = c(1,2,3,4,5,6,7,8,9,10), untransformed_accuracy = unlist(first_accuracy), 
                transformed_accuracy = unlist(second_accuracy))
knndfsplitstall <- melt(knndfsplits, id = "K")

ggplot((knndfsplitstall), aes(x=K, y=value, color=variable)) +
  geom_point() + 
  geom_line() + 
  theme_minimal() +
  ggtitle("KNN Accuracy by K Value, Both Splits")
```


# (e) Write a paragraph for your conclusion.



## 5 Reproducibility
In addition to a writeup of the above results, please provide a one-line link to a public GitHub repository containing everything necessary to reproduce your writeup. Specifically, imagine that at some point an error is discovered in the three image files, and a future researcher wants to check whether your results hold up with the new, corrected image files. This researcher should be able to easily re-run all your code and produce all your figures and tables. This repository should contain:

(i) The pdf of the report,
(ii) the raw Latex, Rnw or Word used to generate your report,
(iii) your R code (with CVgeneric function in a separate R file),
(iv) a README file describing, in detail, how to reproduce your paper from scratch (assume researcher has access to the images).

 We need two things:
(a) A main pdf report (font size at least 11 pt, less or equal to 12 pages)
generated by Latex, Rnw or Word is required to be submitted to Gradescope.
– Provide top class (research-paper level) writing, useful well-labeled figures and no code in this pdf. Arrange text and figures compactly (.Rnw may not be very useful for this).
– ***You can choose a title for the report and a team name as per your liking (get creative!). Do provide the names and student ID of your teammates below the title.***
– Your report should conclude with an acknowledgment section, where you provide brief discussion about the contributions of each member, and the resources you used, credit all the help you took and briefly outline the way you proceeded with the project.
(b) A link to your GitHub Repo at the end of your write-up that contains all your code (see Section 5 for more details).


#Acknowledgments

contributions of each member:
1 a) Omri b) Phoebe c) Omri
2 a) Phoebe b) Omri c) Omri d) Phoebe
3 a) Phoebe Omri b) Omri Phoebe c) *do we want to do the bonus?*
4 a) Omri b) Phoebe c) Omri d) e)
5 

resources used: 
raaz office hours, professor office hours, ESL textbook, ISL textbook, and the following sites 
http://uc-r.github.io/discriminant_analysis
http://cseweb.ucsd.edu/~dasgupta/papers/nn-rates.pdf
https://maths-people.anu.edu.au/~johnm/courses/mathdm/2008/pdf/r-exercisesVI.pdf
https://www.displayr.com/linear-discriminant-analysis-in-r-an-introduction/
https://tgmstat.wordpress.com/2014/01/15/computing-and-visualizing-lda-in-r/
https://rpubs.com/ifn1411/LDA
https://stackoverflow.com/questions/20197106/linear-discriminant-analysis-plot-using-ggplot2
https://stackoverflow.com/questions/14085281/multiple-roc-curves-in-one-plot-rocr
https://stackoverflow.com/questions/11741599/how-to-plot-a-roc-curve-for-a-knn-model

brief outline of how we proceeded with the project:


